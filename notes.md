# yazi

## 私有化析构函数的作用

在C++中，将析构函数声明为私有（private）的意味着只有类内部的其他成员函数可以调用它，而无法从类外部直接调用。私有化析构函数主要有以下几个作用：

- 防止对象在堆栈上被创建：私有化析构函数可以防止类的对象在自动存储（堆栈）上被创建。如果析构函数是私有的，那么只能在类内部创建对象，不允许在类的外部创建对象。这在某些特定情况下可以实现对对象的控制，例如使用单例模式或禁止直接创建对象的设计。

- 禁止对象通过 delete 销毁：私有化析构函数可以防止对象通过 delete 运算符被销毁。当析构函数是私有的时候，只能在类内部进行对象的销毁操作，而在类的外部无法直接调用 delete 销毁对象。这种方式常用于实现对象池（Object Pool）等特定的资源管理模式，确保对象的生命周期由类自身来控制。

请注意，私有化析构函数并不意味着完全禁止对象的销毁，因为类内的其他成员函数仍可以调用该析构函数来销毁对象。它只是限制了析构函数的可见性和访问权限。

## 单例模式

单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供全局访问该实例的方式。单例模式常用于需要全局唯一性的对象，例如日志记录器、数据库连接池、线程池等。

要实现单例模式，一般需要满足以下几个条件：

- 私有化构造函数：将类的构造函数声明为私有，这样外部无法直接通过构造函数创建类的实例。

- 静态成员变量：在类的内部定义一个静态成员变量，用于保存类的唯一实例。

- 静态成员函数：提供一个静态成员函数用于获取类的实例。该函数负责创建实例（如果实例不存在），并返回实例的引用。

下面是一个简单的示例代码，展示了如何实现单例模式：

```cpp
class Singleton {
private:
    static Singleton* instance;

    // 将构造函数和析构函数声明为私有，禁止外部直接创建和销毁实例
    Singleton() {}
    ~Singleton() {}

public:
    // 提供静态成员函数获取实例
    static Singleton& getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return *instance;
    }

    // 其他成员函数
    void doSomething() {
        // ...
    }
};
// 在类外初始化静态成员变量
Singleton* Singleton::instance = nullptr;
```

在上述示例中，Singleton类通过将构造函数和析构函数声明为私有，确保其他代码无法直接通过构造函数创建实例或销毁实例。而通过getInstance静态成员函数来获得Singleton类的唯一实例，如果实例不存在则创建实例并返回。

使用单例模式时要注意以下几点：

- 线程安全：在多线程环境下，需要考虑并发访问的安全问题。可以通过加锁机制或双重检查锁定等方式来保证线程安全性。

- 生命周期管理：单例模式中的实例一般在整个应用程序生命周期中存在，因此需要注意内存泄漏和资源释放的问题。

- 测试难度：由于单例类的全局可访问性，可能会对测试造成困扰。在编写单元测试时，需要考虑如何创建和销毁单例实例，以及如何隔离单例对其他代码的影响。

总结来说，单例模式通过限制一个类只能有一个实例，并提供全局访问的方式，可以满足某些场景下对对象唯一性的需求。然而，它也容易导致全局状态和耦合性增加，因此在使用时需要慎重权衡。